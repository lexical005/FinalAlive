# -*- coding: utf-8 -*-
# 使用 protoc-3.2.0.exe 生成协议

import os
import sys

configfile = open("gen_message.gen", "r")
message_cfg = configfile.read()
configfile.close()

configfile = open("gen_struct.gen", "r")
struct_cfg = configfile.read()
configfile.close()

msg_types = []
custom_msg = [
]

def parse(text, ismsg):
	output = ''
	result = ''
	while True:
		zsstart = text.find('/*')
		if zsstart != -1:
			result += text[:zsstart]
		else:
			result += text
			break
		zsend = text.find('*/', zsstart)
		if zsend != -1:
			text = text[zsend+2:]
		else:
			break
	text = result
	text = text.strip()
	msgs = text.split('@')
	for msg in msgs:
		msg = msg.strip()
		if msg == '':
			continue
		output += parse_msg(msg, ismsg)

	if not ismsg:
		return output

	enumstr = ''
	type_i = 0
	for t in msg_types:
		enumstr += '\t' + t + ' = %d;\n' % type_i
		type_i += 1
	for one in custom_msg:
		enumstr += '\t' + one[0] + ' = %d;\n' % (one[1],)
	enumstr = '''enum MessageType {
%s}''' % enumstr
	output = enumstr + '\n\n' + output
	return output

def parse_msg(msg, ismsg):
	msg_top = {}
	top_sec = []
	msg_member = ''
	lines = msg.split('\n')
	msg_name = lines[0].strip()
	print(msg_name)
	mem_i = 1
	for line in lines[1:]:
		line = line.strip()
		if line == '':
			continue

		tags = line.split()
		if len(tags) == 1:
			pass
		elif len(tags) == 2:
			msg_member +='\t' + line + ' = %d;\n' % mem_i
		else:
			msg_member += '\t' + line + ' = %d;\n' % mem_i
		mem_i += 1



	if ismsg:
		if msg_name.find('Msg') != 0:
			go_error('Proto message must start with Msg')
		msg_types.append(msg_name[len('Msg'):])
		output = '''message %s{\n%s}\n\n''' % (msg_name, msg_member)
	else:
		output = '''message %s{\n%s}\n\n''' % (msg_name, msg_member)

	return output

message_proto_header = '''// Generated by the msggen.py message compiler.
'''

def save_go():
	t = '''
	package ffProto

	import "github.com/golang/protobuf/proto"

	'''


	t1 = 'var listMessageID = []MessageType{\n'
	t2 = 'var mapMessageCreator = map[MessageType]func() interface{}{\n'
	for mt in msg_types:
		t1 += 'MessageType_' + mt + ',\n'
		t2 += '''MessageType_%s: func() interface{} {
			return &Msg%s{}
		},
		''' % (mt, mt)
	t1 += '}\n\n'
	t2 += '}\n\n'

	text = '''
	package ffProto

	'''
	text += t1
	text += t2

	f = open('Server/message.pb.go', 'w+')
	f.write(text)
	f.close()

def save_csharp():
	t_header = '''
public partial class Message
{
\tprivate delegate Google.Protobuf.IMessage MessageCreator(byte[] data, int offset, int length);
	'''

	t_type_header = '''
\tprivate static readonly Dictionary<MessageType, MessageCreator> s_mapMessageCreator = new Dictionary<MessageType, MessageCreator>
\t{'''

	t_type_loop = '''\n\t\t{ %s, MessageType.%s },'''

	t_type_tail = '''\n\t};\n'''

	t_creator_header = '''
\tprivate static readonly Dictionary<int, MessageCreator> s_mapMessageCreator = new Dictionary<int, MessageCreator>
\t{'''

	t_creator_loop = '''\n\t\t{ %s, delegate (byte[] data, int offset, int length) { return %s.Parser.ParseFrom(data, offset, length); } },'''

	t_creator_tail = '''\n\t};\n'''

	t_tail = '''}\n'''

	text = t_header
	text += t_type_header
	for id, mt in enumerate(msg_types):
		text += t_type_loop % (id, mt)
	text += t_type_tail
	text += t_creator_header
	for id, mt in enumerate(msg_types):
		text += t_creator_loop % (id, mt)
	text += t_creator_tail
	text += t_tail

	f = open('Client/Message.cs', 'w+')
	f.write(text)
	f.close()

def saveoutput(text):
	global message_proto_header
	proto_header = 'syntax = "proto3";\n\n'
	text = proto_header + message_proto_header + text

	f = open('Server/ffProto.proto', 'w+')
	f.write(text)
	f.close()

	f = open('Client/Proto.proto', 'w+')
	f.write(text)
	f.close()

def go_error(error_msg):
	print error_msg
	os.system('color 4a')
	exit(1)

if __name__ == '__main__':
	saveoutput(parse(struct_cfg, False) + parse(message_cfg, True))
	print('\n')

	save_go()
	save_csharp()
	print('\n')
